<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>Decryptor | ROAA | Rucoy Online Assets Archive</title>
    <meta name="description" content="This is ROAA, Rucoy Online Assets Archive, it's purpose is to archive all the assets from each version of Rucoy Online." />
    <meta name="og:title" content="ROAA | Rucoy Online Assets Archive">
    <meta name="og:description" content="This is ROAA, Rucoy Online Assets Archive, it's purpose is to archive all the assets from each version of Rucoy Online.">
    <meta name='keywords' content='Rucoy, rucoy, Rucoy Online, Rucoy online, rucoy Online, rucoy online, Rucoy Assets, Rucoy assets, rucoy Assets, rucoy assets, Rucoy Online Assets, Rucoy Online assets, Rucoy online Assets, Rucoy online assets, rucoy Online Assets, rucoy Online assets, rucoy online Assets, rucoy online assets'>
    <meta name="robots" content="index, follow">
    <meta name="author" content="Border Blade Cz">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/prism.css">
    <script src="js/prism.js"></script>
  </head>
  <body>
   <pre>
	  <code class="language-python">
import os


def find_all_png_data(file_path):
    with open(file_path, "rb") as file:
        data = file.read()

        start_idx = 0
        png_data_list = []

        while True:
            start_idx = data.find(b"\x89PNG", start_idx)
            if start_idx == -1:
                break

            end_idx = data.find(b"\x49\x45\x4E\x44\xAE\x42\x60\x82", start_idx + 1)
            if end_idx == -1:
                print(f"End of PNG data not found in the file: {file_path}")
                return None

            png_data = data[start_idx : end_idx + 8]
            png_data_list.append(png_data)

            start_idx = end_idx + 1

        return png_data_list


def build_png_files(png_data_list, output_dir):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for i, png_data in enumerate(png_data_list, start=1):
        output_path = os.path.join(output_dir, f"output_file_{i}.png")
        with open(output_path, "wb") as outfile:
            outfile.write(png_data)
        print(f"PNG data extracted and saved to: {output_path}")


if __name__ == "__main__":
    file_paths = ["c1", "c2", "c7", "c8", "c9", "mi", "nm1", "nm3", "nm4", "oi"]

    for input_file_path in file_paths:
        output_dir = f"{os.path.splitext(input_file_path)[0]}_output"
        png_data_list = find_all_png_data(input_file_path)
        if png_data_list:
            build_png_files(png_data_list, output_dir)
        else:
            print(f"No PNG data found in the file: {input_file_path}")
    </code>
	 </pre>
	 <pre>
	     <code class="language-java">
	         import java.io.*;
import java.nio.file.*;
import java.util.*;

public class Main {

    public static List<byte[]> find_all_png_data(String file_path) throws IOException {
        byte[] data = Files.readAllBytes(Paths.get(file_path));
        int start_idx = 0;
        List<byte[]> png_data_list = new ArrayList<>();

        while (true) {
            start_idx = findBytes(data, new byte[]{(byte) 0x89, (byte) 'P', (byte) 'N', (byte) 'G'}, start_idx);
            if (start_idx == -1) {
                break;
            }

            int[] end_pattern = {0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
            int end_idx = findBytes(data, intArrayToByteArray(end_pattern), start_idx + 1);
            if (end_idx == -1) {
                System.out.println("End of PNG data not found in the file: " + file_path);
                return null;
            }

            byte[] png_data = Arrays.copyOfRange(data, start_idx, end_idx + 8);
            png_data_list.add(png_data);

            start_idx = end_idx + 1;
        }

        return png_data_list;
    }

    public static void build_png_files(List<byte[]> png_data_list, String output_dir) throws IOException {
        File dir = new File(output_dir);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        for (int i = 0; i < png_data_list.size(); i++) {
            byte[] png_data = png_data_list.get(i);
            String output_path = Paths.get(output_dir, "output_file_" + (i + 1) + ".png").toString();
            Files.write(Paths.get(output_path), png_data);
            System.out.println("PNG data extracted and saved to: " + output_path);
        }
    }

    public static int findBytes(byte[] data, byte[] pattern, int start_idx) {
        for (int i = start_idx; i < data.length - pattern.length; i++) {
            boolean found = true;
            for (int j = 0; j < pattern.length; j++) {
                if (data[i + j] != pattern[j]) {
                    found = false;
                    break;
                }
            }
            if (found) {
                return i;
            }
        }
        return -1;
    }

    public static byte[] intArrayToByteArray(int[] array) {
        byte[] result = new byte[array.length];
        for (int i = 0; i < array.length; i++) {
            result[i] = (byte) array[i];
        }
        return result;
    }

    public static void main(String[] args) {
        String[] file_paths = {"c1", "c2", "c7", "c8", "c9", "mi", "nm1", "nm3", "nm4", "oi"};

        for (String input_file_path : file_paths) {
            String output_dir = Paths.get(Paths.get(input_file_path).getFileName().toString()).toString() + "_output";
            try {
                List<byte[]> png_data_list = find_all_png_data(input_file_path);
                if (png_data_list != null) {
                    build_png_files(png_data_list, output_dir);
                } else {
                    System.out.println("No PNG data found in the file: " + input_file_path);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code>
	 </pre>
	 <pre>
	     <code class="language-c">
	         #include <stdio.h>
#include <stdlib.h>
#include <string.h>

void find_all_png_data(const char *file_path) {
    FILE *file = fopen(file_path, "rb");
    if (file == NULL) {
        perror("Error opening file");
        return;
    }

    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    rewind(file);

    unsigned char *data = (unsigned char *)malloc(file_size);
    if (data == NULL) {
        perror("Error allocating memory");
        fclose(file);
        return;
    }

    fread(data, 1, file_size, file);
    fclose(file);

    long start_idx = 0;
    long end_idx = 0;
    long search_idx = 0;
    char *png_signature = "\x89PNG";
    char *end_signature = "\x49\x45\x4E\x44\xAE\x42\x60\x82";

    while (search_idx < file_size) {
        start_idx = search_idx;
        while (start_idx < file_size - 3 && memcmp(data + start_idx, png_signature, 4) != 0) {
            start_idx++;
        }

        if (start_idx >= file_size - 3) {
            break;
        }

        end_idx = start_idx + 1;
        while (end_idx < file_size - 7 && memcmp(data + end_idx, end_signature, 8) != 0) {
            end_idx++;
        }

        if (end_idx >= file_size - 7) {
            fprintf(stderr, "End of PNG data not found in the file: %s\n", file_path);
            free(data);
            return;
        }

        // Process png_data from start_idx to end_idx + 7
        printf("PNG data found: %ld to %ld\n", start_idx, end_idx + 7);

        search_idx = end_idx + 8;
    }

    free(data);
}

int main() {
    const char *file_paths[] = {"c1", "c2", "c7", "c8", "c9", "mi", "nm1", "nm3", "nm4", "oi"};
    int num_files = sizeof(file_paths) / sizeof(file_paths[0]);

    for (int i = 0; i < num_files; i++) {
        find_all_png_data(file_paths[i]);
    }

    return 0;
}</code>
	 </pre>
	 <pre>
	     <code class="language-cpp">
	         #include <iostream>
#include <fstream>
#include <vector>
#include <cstring>
#include <sys/stat.h>

std::vector<char> find_all_png_data(const std::string& file_path) {
    std::ifstream file(file_path, std::ios::binary);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << file_path << std::endl;
        return std::vector<char>();
    }

    std::vector<char> data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());

    size_t start_idx = 0;
    std::vector<std::vector<char>> png_data_list;

    while (true) {
        start_idx = data.find("PNG", start_idx);
        if (start_idx == std::string::npos) {
            break;
        }

        size_t end_idx = data.find("IEND\xAE\x42\x60\x82", start_idx + 1);
        if (end_idx == std::string::npos) {
            std::cerr << "End of PNG data not found in the file: " << file_path << std::endl;
            return std::vector<char>();
        }

        std::vector<char> png_data(data.begin() + start_idx, data.begin() + end_idx + 8);
        png_data_list.push_back(png_data);

        start_idx = end_idx + 1;
    }

    return png_data_list;
}

void build_png_files(const std::vector<std::vector<char>>& png_data_list, const std::string& output_dir) {
    if (mkdir(output_dir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) != 0) {
        std::cerr << "Failed to create output directory: " << output_dir << std::endl;
        return;
    }

    for (size_t i = 0; i < png_data_list.size(); ++i) {
        const std::vector<char>& png_data = png_data_list[i];
        std::string output_path = output_dir + "/output_file_" + std::to_string(i + 1) + ".png";
        std::ofstream outfile(output_path, std::ios::binary);
        if (outfile.is_open()) {
            outfile.write(png_data.data(), png_data.size());
            std::cout << "PNG data extracted and saved to: " << output_path << std::endl;
        } else {
            std::cerr << "Failed to write output file: " << output_path << std::endl;
        }
    }
}

int main() {
    std::vector<std::string> file_paths = {"c1", "c2", "c7", "c8", "c9", "mi", "nm1", "nm3", "nm4", "oi"};

    for (const std::string& input_file_path : file_paths) {
        std::string output_dir = input_file_path.substr(0, input_file_path.find_last_of('.')) + "_output";
        std::vector<std::vector<char>> png_data_list = find_all_png_data(input_file_path);
        if (!png_data_list.empty()) {
            build_png_files(png_data_list, output_dir);
        } else {
            std::cerr << "No PNG data found in the file: " << input_file_path << std::endl;
        }
    }

    return 0;
}</code>
	 </pre>
	 <pre>
	     <code class="language-csharp">
	         using System;
using System.IO;
using System.Collections.Generic;

class Program
{
    static List<byte[]> FindAllPngData(string filePath)
    {
        List<byte[]> pngDataList = new List<byte[]>();

        using (FileStream file = new FileStream(filePath, FileMode.Open, FileAccess.Read))
        {
            byte[] data = new byte[file.Length];
            file.Read(data, 0, data.Length);

            int startIdx = 0;
            while (true)
            {
                startIdx = Array.IndexOf(data, (byte)0x89, startIdx);
                if (startIdx == -1)
                {
                    break;
                }

                int endIdx = Array.IndexOf(data, (byte)0x82, startIdx + 8); // Finding the end of PNG data marker
                if (endIdx == -1)
                {
                    Console.WriteLine($"End of PNG data not found in the file: {filePath}");
                    return null;
                }

                byte[] pngData = new byte[endIdx - startIdx + 8];
                Array.Copy(data, startIdx, pngData, 0, pngData.Length);
                pngDataList.Add(pngData);

                startIdx = endIdx + 8;
            }
        }

        return pngDataList;
    }

    static void BuildPngFiles(List<byte[]> pngDataList, string outputDir)
    {
        if (!Directory.Exists(outputDir))
        {
            Directory.CreateDirectory(outputDir);
        }

        for (int i = 0; i < pngDataList.Count; i++)
        {
            string outputFilePath = Path.Combine(outputDir, $"output_file_{i + 1}.png");
            using (FileStream outputFile = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
            {
                outputFile.Write(pngDataList[i], 0, pngDataList[i].Length);
            }

            Console.WriteLine($"PNG data extracted and saved to: {outputFilePath}");
        }
    }

    static void Main(string[] args)
    {
        string[] filePaths = { "c1", "c2", "c7", "c8", "c9", "mi", "nm1", "nm3", "nm4", "oi" };

        foreach (string inputFilePath in filePaths)
        {
            string outputDir = $"{Path.GetFileNameWithoutExtension(inputFilePath)}_output";
            List<byte[]> pngDataList = FindAllPngData(inputFilePath);
            if (pngDataList != null)
            {
                BuildPngFiles(pngDataList, outputDir);
            }
            else
            {
                Console.WriteLine($"No PNG data found in the file: {inputFilePath}");
            }
        }
    }
}</code>
	 </pre>
	 <pre>
	     <code class="language-go">
	         package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

func findStartIndex(data []byte, startIndex int) int {
	return strings.Index(data[startIndex:], "\x89PNG")
}

func findEndIndex(data []byte, startIndex int) int {
	return strings.Index(data[startIndex:], "\x49\x45\x4E\x44\xAE\x42\x60\x82") + startIndex + 8
}

func findAllPNGData(filePath string) [][]byte {
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		fmt.Printf("Error reading file: %v\n", err)
		return nil
	}

	startIndex := 0
	pngDataList := [][]byte{}

	for {
		startIndex = findStartIndex(data, startIndex)
		if startIndex == -1 {
			break
		}

		endIndex := findEndIndex(data, startIndex+1)
		if endIndex == -1 {
			fmt.Printf("End of PNG data not found in the file: %s\n", filePath)
			return nil
		}

		pngData := data[startIndex:endIndex]
		pngDataList = append(pngDataList, pngData)

		startIndex = endIndex + 1
	}

	return pngDataList
}

func buildPNGFiles(pngDataList [][]byte, outputDir string) {
	if _, err := os.Stat(outputDir); os.IsNotExist(err) {
		os.MkdirAll(outputDir, os.ModePerm)
	}

	for i, pngData := range pngDataList {
		outputPath := fmt.Sprintf("%s/output_file_%d.png", outputDir, i+1)
		err := ioutil.WriteFile(outputPath, pngData, os.ModePerm)
		if err != nil {
			fmt.Printf("Error writing PNG data to file: %v\n", err)
		} else {
			fmt.Printf("PNG data extracted and saved to: %s\n", outputPath)
		}
	}
}

func main() {
	filePaths := []string{"c1", "c2", "c7", "c8", "c9", "mi", "nm1", "nm3", "nm4", "oi"}

	for _, inputFile := range filePaths {
		outputDir := fmt.Sprintf("%s_output", strings.TrimSuffix(inputFile, ".txt"))
		pngDataList := findAllPNGData(inputFile)
		if pngDataList != nil {
			buildPNGFiles(pngDataList, outputDir)
		} else {
			fmt.Printf("No PNG data found in the file: %s\n", inputFile)
		}
	}
}</code>
	 </pre>
  </body>
</html>
